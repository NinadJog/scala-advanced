package part1as

object Recap {

  /** Case class features already generated by the compiler
   * 1. Constructor arguments are automatically promoted to fields
   * 2. A companion object with an apply method so we don't have to use new
   * 3. Methods such as toString, equals, and hashCode are already implemented
   * 4. Case classes are serializable
   */
  case class Person(name: String, age: Int)

  // enums define a finite number of possibilities
  enum BasicColors:
    case RED, GREEN, BLUE

  // functional programming
  val incrementer = new Function1[Int, Int]:
    override def apply(x: Int): Int = x + 1

  val two     = incrementer.apply(1)
  val alsoTwo = incrementer(1)

  // lambdas
  // Int => Int is syntax sugar for Function1[Int, Int]
  val anonIncremmenter:   Int => Int = x => x + 1
  val anonIncrementer_v2: Int => Int = _ + 1
  val anonIncrementer_v3 = (x: Int) => x + 1

  // braceless syntax. Applies also for if, match, while (in addition to for-comprehensions)
  val pairs: Seq[String] =
    for
      number  <- List(1, 2, 3)
      char    <- List('a', 'b', 'c')
    yield s"$number-$char"

  // indentation tokens
  class BracelessAnimal:
    def eat(): Unit =
      println("I'm eating something")
    end eat // end is optional
  end BracelessAnimal

  def main(args: Array[String]): Unit = {

  }
}
